---
code-annotations: hover
citation-location: margin
---

# Rapporteren en Presenteren van Resultaten {#sec-reporting-and-presenting-results}

```{r}
#| label: setup
#| echo: false
#| message: false
#| warning: false

#Packages
library(rio)             #laden van data
library(tidyverse)       #data manipulatie en grafieken
library(broom)           #samenvattingen regressiemodellen
library(marginaleffects) #voorspelde waarden berekenen
library(modelsummary)    #regressietabellen opstellen

#Data
demdata <- import("data/demdata.rds")

```

Dit document bevat algemene richtlijnen over het correct presenteren en rapporteren van correlaties en lineaire regressiemodellen. Sommige secties hebben een "Rapportage" sub-sectie met instructies over hoe je resultaten bespreekt in rapporten. "Instructies" sub-secties geven verdere tips over hoe je resultaten best visueel presenteert.

We laden de packages en data gebruikt in dit hoofdstuk eerst:

```{r}
#| eval: false 

#Packages
library(rio)             #laden van data
library(tidyverse)       #data manipulatie en grafieken
library(broom)           #samenvattingen regressiemodellen
library(marginaleffects) #voorspelde waarden berekenen
library(modelsummary)    #regressietabellen opstellen

#Data
demdata <- import("demdata.rds")

```

## Puntenwolken of Scatterplots {#sec-report-scatterplots}

We kunnen een visuele weergave tonen van de bivariate relatie tussen twee continue variabelen in een puntenwolk of scatterplot. Hieronder is een voorbeeld voor de variabelen `gini_2019` en `v2x_polyarchy`:

```{r}
#| warning: false
#| message: false

ggplot(demdata, aes(x = gini_2019, y = v2x_polyarchy)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  labs(x = "Economische Ongelijkheid", 
       y = "Electorale Democratie", 
       title = "Economische Ongelijkheid en Electorale Democratie")
```

### Rapportage

De volgende zaken kun je best benoemen wanneer je een scatterplot bespreekt:

-   De richting van de relatie, alsook de sterkte (maar let op dat je best ook de correlatiecoëfficiënt bekijkt gezien visuele weergaven ook misleidend kunnen zijn).
-   Patronen of trends in het plot.
-   Cases die extreme waarden hebben of cases die als outliers kunnen beschreven worden.

### Instructies

-   Zorg ervoor de je informatieve labels hebt voor de x -en y-as en een duidelijke titel.

-   Je kan de regressielijn toevoegen aan het plot om de interpretatie te verduidelijken. Dit kan je doen met de syntax `method = "lm"`. Je kunt de syntax veranderen naar `method = "loess"` om een 'locally estimated scatterplot smoothing' line te plotten. Dit is handig voor het spotten van niet-lineaire patronen in de data. Zie @sec-quadratic-relationships

-   Let op de tekstgrootte op de assen en zorg dat de tekst goed leesbaar is. De grootte van het lettertype kun je aanpassen met de syntax om het visuele thema van de figuur te veranderen, bv. door het volgende toe te voegen: `+ theme_grey(14)` of `+ theme_bw(18)`. Het nummer tussen haakjes bepaalt de grootte van het lettertype.Je kunt een lijst met de ingebouwde visuele ggplot schema's [hier](https://ggplot2.tidyverse.org/reference/ggtheme.html) vinden. Bijkomende opties zijn beschikbaar in het [ggthemes](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/){target="_blank"} package. Meer complexe veranderingen, zoals verschillende tekstgroottes voor titel en astitels, kun je uitvoeren via `theme()`, maar dit behandelen we niet in dit document.

-   Bovenstaand plot toont de bivariate relatie tussen twee continue variabelen met toevoeging van de regressielijn. We kunnen ook de formule van de lijn toevoegen met `geom_text()`. Dit doen we door een `+` toe te voegen na `labs()` en de volgende regel toe te voegen: `geom_text(x = 40, y=0.1, label="Dem Score = 1.06 + (-0.012 * Inequality)")` . De formule vind je met `lm`(zie onder). De `x=` en `y=`gedeelten geven de waarden (coördinaten) weer waar het label in het plot moet komen. Het kan nodig zijn de waarden stelselmatig aan te passen om een mooie weergave te bereiken. Bepaalde packages in R kunnen dit proces vergemakkelijken, zoals deze [functie](https://rpkgs.datanovia.com/ggpubr/reference/stat_regline_equation.html) uit het `ggpubr` package. Dit package behoort niet tot de leerstof.

## Correlaties

Voor dit voorbeeld berekenen we de Pearson correlatie tussen economische ongelijkheid (hogere waarden = meer ongelijk; `gini_2019`) en electorale democratie (hogere waarden = meer democratie; `v2x_polyarchy`).

```{r}
cor1 <- cor.test(x = demdata$gini_2019, 
                 y = demdata$v2x_polyarchy, 
                 method = 'pearson')

cor1
```

Zie @sec-correlation-coefficients voor richtlijnen over de interpretatie van correlatiecoëfficiënten.

### Rapportage

De volgende zaken neem je best op in je rapportage:

-   De specifieke correlatie je gebruikt hebt (bv. Pearson).
-   Een bespreking van de richting van de relatie (positief, negatief, geen relatie), waarbij ook aandacht is voor de codering van gebruikte variabelen.
-   Een bespreking van de statistische significantie:
    -   Significantie hebben we meestal op de niveaus van 95% (p \< 0.05), 99% (p \< 0.01), en 99.9% (p \< 0.001) [^1]
    -   Raporteer op basis van het hoogste signficantieniveau dat de p-waarde aangeeft:
        -   Als p = 0.04, dan p \< 0.05 (significant op 95% niveau)
        -   Als p = 0.02, dan p \< 0.01 (significant op 99% niveau)
        -   Als p = 0.0000005, dan p \< 0.001 (significant op 99.9% niveau)
    -   We rapporteren meestal niet hoger dan 99.9% of p \< 0.001 (bv., we zeggen niet p \< 0.000001, maar p \< 0.001). We schrijven ook nooit p \< 0.000.
-   Een bespreking van de sterkte van de relatie. (zie @sec-correlation-coefficients)

[^1]: Een 90% betrouwbaarheidsniveau kan passend zijn indien het model een lage N heeft.

::: callout-tip
#### Voorbeeld rapportage

Hogere waarden voor economische ongelijkheid hangen samen met lagere waarden voor electorale democratie ($r$ = `r round(cor1$estimate, 2)`). De associatie heeft een gemiddelde sterkte en is statistisch significant (p $<$ 0.01).
:::

### Presentatie: Correlatietabellen

Wanneer we slechts de correlatie tussen twee variabelen beschrijven, kunnen we deze discussie gewoon in onze tekst opnemen zoals hierboven. Wanneer we echter analyses doen met meerdere continue variabelen is het een goede praktijk om een correlatietabel op te stellen die de correlatie tussen deze variabelen weergeeft. Deze tabel kan in de hoofdtekst van een paper of in een appendix worden opgenomen. De tabel kan aangemaakt worden met de `datasummary_correlation()` functie uit het `modelsummary` package. Hier is een voorbeeld met 4 variabelen:

```{r}
demdata |> 
  select(v2x_polyarchy, gini_2019, cpi, gdp_ppp) |> 
  rename("Elec. Democracy" = v2x_polyarchy, 
         "Econ Inequality" = gini_2019, 
         "Corruption" = cpi, 
         "GDP" = gdp_ppp) |> 
  datasummary_correlation(method = "pearson",
                          title = "Relationship between Main Continuous Variables")
```

::: callout-note
#### Output uitleg

Elke cel bevate een correlatiecoëfficiënt voor 2 gepaarde variabelen. De correlatie tussen corruptie en economische ongelijkheid is bijvoorbeeld -0,53, terwijl de correlatie tussen GDP en corruptie 0,79 is.

Opmerking: De titel wordt in dit document onderaan de tabel weergegeven, maar wordt bovenaan afgedrukt bij het opslaan in een Word-document (zie hieronder), wat de meer conventionele plaatsing is.
:::

Zo lees je de syntax:

`demdata |> select(…)`

:   Hier selected we de dataset (`demdata`) en de variabelen waartussen we de correlaties willen berekenen. Zonder `select(…)` berekent R de correlaties tussen alle variabelen in de dataset!

`rename(…)`

:   We geven de variabelen een andere naam zodat presentatie van de variabelen in de tabel duidelijker is voor lezers.

`datasummary_correlation(method = "pearson", title = "...")`

:   Hier duiden we aan welke correlatie we precies willen en geven we een duidelijke titel (Pearson correlation: method = "pearson"; Spearman: method = "spearman").

We kunnen deze tabel naar een Microsoft Word bestand exporteren zodat we de tabel kunnen gebruiken in eigen papers met volgende syntax toevoeging (Je ziet de tabel nu wel niet langer in R verschijnen):

```{r}
demdata |> 
  select(v2x_polyarchy, gini_2019, cpi, gdp_ppp) |> 
  rename("Elec. Democracy" = v2x_polyarchy, 
         "Econ Inequality" = gini_2019, 
         "Corruption" = cpi, 
         "GDP" = gdp_ppp) |> 
  datasummary_correlation(method = "pearson",
                          title = "Relationship between Main Continuous Variables", 
                          output = "correlation table example.docx")

```

`output = "correlation table example.docx"`

:   Hier vragen we de output te exporteren naar een Word (.docx) bestand. De naam van het bestand bepaal je zelf. Het bestand is terug te vinden in je projectfolder of de folder waar je syntax bestand (script of Markdown) zich in bevindt. In Word kunnnen nog verdere aanpassingen worden gedaan. [^2]

[^2]: We willen bijvoorbeeld misschien asteriks toevoegen voor statistische significantie. Dit lukt niet gemakkelijk vanzelf met `datasummary_correlation` (De website van het package beschrijft wel [deze methode](https://modelsummary.com/vignettes/datasummary.html#datasummary_correlation){target="_blank"}).Je kunt ook altijd `cor.test`gebruiken om significantie na te gaan.

::: callout-important
#### Waarschuwing!

Je kunt problemen tegenkomen met deze syntax indien je je Word-bestand met tabel open hebt in Word en de syntax nogmaals runt, bijvoorbeeld om een foutje te corrigeren. We raden aan het Word bestand altijd te sluiten voor je de syntax opnieuw runt.
:::

#### Instructies

-   Doorgaans plaatsen we de afhankelijke variabele op de eerste rij in een correlatietabel. Dit doe je door de variabele als eerste te noemen in de `select()` regel van de syntax hierboven.
-   De variabelen hernoem je zodat het duidelijk is voor de lezer wat ze inhouden. Gebruik dus niet gewoon de naam van de variabelen zoals ze opgeslagen zijn in de dataset.
-   Geef de tabel een informatieve titel.
-   Het is gebruikelijk om asterisks te plaatsen in de tabel om statistische significantie weer te geven (\*\*\* = p \< 0.01, \*\* = p \< 0.01, \* = p \< 0.05). Jammergenoeg kan `datasummary_correlation()` dit niet automatisch toevoegen. Wel kun je deze symbolen manueel (op basis van `cor.test`) toevoegen aan een tabel in een .docx (Word) bestand.
-   Correlatie (en regressie) tabellen gemaakt met `modelsummary` kun je verder aanpassen met instructies op [deze webpagina](https://modelsummary.com/vignettes/appearance.html){target="_blank"}. Dit is echter niet nodig voor dit vak.

## OLS Regressiemodellen {#sec-reporting-linear-regression}

Lineaire regressie, oftewel OLS (Ordinary Least Squares) regressie modelleert veranderingen in het gemiddelde van een afhankelijke variabele als lineaire functie van een of meerdere onafhankelijke variabelen. We gebruiken hier de `demdata` dataset en voorspellen electorale democratiescores in het jaar 2020 als functie van economische ongelijkheid (gini_2019), de status van het regime van een land in 1984 (TYPEDEMO1984) en regio van de wereld waarin een land is gesitueerd (1 = Europa, 2 = Afrika, 3 = Azië, 4 = Amerikas).

Hieronder vind je de syntax en output in R. Deze output neem je niet rechtstreeks op in een paper. In de plaats daarvan maak je een formele tabel of een coëfficiëntenplot (zie onder).

```{r}
#| echo: false
#create region variable
demdata <- demdata |>
  mutate(region = case_when(
      e_regiongeo %in% c(1:4) ~ 1, 
      e_regiongeo %in% c(5:9) ~ 2, 
      e_regiongeo %in% c(10:15) ~ 3, 
      e_regiongeo %in% c(16:19) ~ 4))

```

```{r}
#Factorize categorical variables
demdata <- demdata |> 
  mutate(TYPEDEMO1984 = factorize(TYPEDEMO1984), 
         region = factor(region, 
                    levels=c(2,3,1,4), #Ref group is listed first
                    labels=c("Africa", "Asia", "Europe", "Americas")))

#model schatten en opslaan
example_model <- lm(v2x_polyarchy ~ gini_2019 + TYPEDEMO1984 + region, 
                    data=demdata)

#Resultaten
summary(example_model)
```

Voor interpretatierichtlijnen, zie @sec-performing-a-multiple-linear-regression.

### Rapportage

Je rapport bevat best de volgende zaken:

-   Een bespreking van de richting van de relatie (positief/negatief) en een inhoudelijke interpretatie van wat dit concreet betekent op basis van hoe de variabelen gemeten zijn en welke schaal zij hebben.
    -   Bij een multiple regressie is het belangrijk te verduidelijken dat het effect dat je vindt voor een onafhankelijke variabele gecontroleerd is op de andere onafhankelijke variabelen in het model. Deze worden 'constant gehouden' (oftewel 'ceteris paribus').
-   Een bespreking van de statistische significantie (verwerpen of niet nulhypothese?) met vermelding van p-waarde en/of het betrouwbaarheidsinterval.
    -   Coëfficiënten met p-waarden groter dan 0.05 worden meestal niet als statistisch significant of als statistisch significant bij conventionele niveaus beschouwd.[^3] Rapporteer op basis van het hoogste signficantieniveau dat de p-waarde aangeeft:
        -   Als p = 0.04, dan p \< 0.05 (significant op 95% niveau)
        -   Als p = 0.02, dan p \< 0.01 (significant op 99% niveau)
        -   Als p = 0.0000005, dan p \< 0.001 (significant op 99.9% niveau)
        -   We rapporteren meestal niet hoger dan 99.9% of p \< 0.001 (bv., we zeggen niet p \< 0.000001, maar p \< 0.001). We schrijven ook nooit p \< 0.000.
    -   Het betrouwbaarheidsinterval kan ook gebruikt worden om statistische significantie te bespreken en de onzekerheid rond de geschatte coëfficiënten aan te duiden. Als je het betrouwbaarheidsinterval bespreekt, kun je dit tussen haakjes toevoegen na de coëfficiënt, bv. "De coëfficiënt voor economische ongelijkheid is 0.8 (95% CI: 0.5, 1.1)".
    -   Het is minder gebruikelijk de t-statistiek concreet te benoemen, maar het is ook geen probleem als je dit doet. Indien de t-waarde wordt opgenomen, zet je deze bij de p-waarde: "(t = 1.98, p \< 0.05)".

[^3]: Een 90% betrouwbaarheidsniveau kan passend zijn indien het model een lage N heeft.

Hier vind je uitgewerkte voorbeelden voor `gini_2019` (een continue variabele) en `TYPEDEMO1984` (een binaire variabele).

::: {.callout-tip title="Report"}
**gini_2019**: We verwachten dat het niveau van electorale democratie lager is als economische ongelijkheid stijgt, gecontroleerd op de effecten van regimestatus in het verleden en regio in de wereld. Gebaseerd op het model verwachten we dat electoral democratie met -0.01 eenheden daalt als economische ongelijkheid met 1 eenheid stijgt. Dit effect is statistisch signifcant (p \< 0.05).

**TYPEDEMO1984**: Het regressiemodel toont dat landen die als democratie werden beschouwd in 1984 ook vandaag democratischer zijn. Gemiddeld genomen scoren deze landen 0.07 eenheden hoger op electorale democratie in 2020 dan landen die in 1984 geen democratie waren, gecontroleerd op ongelijkheid en regio in de wereld. Het verschil is echter niet statistisch significant (p \> 0.05).
:::

Bijkomende tips:

-   In een bespreking van een onderzoek kun je behalve een discussie van de coëfficiënten ook een bespreking van voorspelde waarden opnemen (bv. welk niveau van democratie verwacht je bij hoge en lage ongelijkheid volgens je model). Een plot van voorspelde waarden kan de bespreking verder verduidelijken. Zie @sec-presenting-linear-regression-predicted-values-plots voor meer informatie.
-   Als je onderzoek vooral gericht is op de relatie tussen een specifieke onafhankelijke variabele en de afhankelijke variabele dan is een discussie van de coëfficiënten van de controlevariabelen doorgaans niet nodig.
-   Het intercept wordt zelden vermeld in onderzoekspapers. In een bivariaat model waarbij de predictor binair is, is het intercept wel inhoudelijk interessant, want dan staat de 0 voor de gemiddelde score op de afhankelijke variabele voor de referentiecategorie. In een experiment zou je bijvoorbeeld scores vergelijken van de controlegroep (X=0) en de experimentele groep (x=1).
-   Wees voorzichting in je bespreking van de relatie tussen de variabelen. Causaliteit is moeilijk te bepalen en is onderhevig aan sterke voorwaarden. Je schrijft bijgevolg dus meestal niet het "effect van X op Y" , maar "deze verandering in X is geassocieerd met deze verandering in Y".

## Lineaire Regressietabellen {#sec-presenting-linear-regression-regression-tables}

Een gebruikelijke methode om de resultaten van regressiemodellen te presenteren is met behulp van een tabel. Via het `modelsummary`package (en functie met dezelfde naam) kunnen we R gebruiken om zo'n tabel aan te maken.

### Regressietabel voor 1 model

Als voorbeeld maken we hier een regressietabel voor een model waarin de score voor electorale democratie voorspeld wordt aan de hand van 1 onafhankelijke variabele: de corruptieperceptie-index (`cpi`). Hieronder vinden we de standaard output zonder toevoegingen:

```{r}
#Schatten en opslaan van het model
model1 <- lm(v2x_polyarchy ~ cpi, data = demdata)

#basisfunctie voor regressietabel
modelsummary(model1)
```

`modelsummary(`

:   Naamn van de functie

`model1,`

:   naam van het model waarvan we de resultaten in een tabel willen presenteren.

Deze tabel kan verbeterd worden. Ten eerste kunnen we de statistische significantie van de coëfficiënten aanduiden met een asterisk (\*) of andere symbolen. Ten tweede kunnen we onze variabelen duidelijkere labels geven. Ten derde kunnen we model fit statistieken die minder interessant zijn weglaten uit de tabel. Ten slotte kunnen we een titel en onderschrift toevoegen.

Dit doen we met volgende syntax:

```{r}

modelsummary(model1, 
             stars = TRUE, # <1>             
             coef_rename = c(    # <2>             
               "(Intercept)" = "Constante",
               "cpi" = "Corruptieperceptie-index"), 
             gof_map = c("nobs", "r.squared", "adj.r.squared"), # <3>
             title = "Electorale Democratie voorspeld door corruptie", # <4>
             notes = "Lineaire regressiecoëfficiënten met standaardfouten tussen haakjes") # <5> 

```

1.  Voegt "stars" of asterisks toe voor statistische significantie.
2.  We hernoemen de variabeln voor de duidelijkheid `coef_rename()`
3.  We selecteren de fit statistieken die we willen rapporteren `gof_map()`
4.  We geven een titel aan de table `title =`
5.  En ten slotte geven we informatie aan de lezer over wat we precies weergeven `notes =`

`stars = TRUE,`

:   Met deze optie voegen we symbolen voor statistische significantie toe. De legende voor de symbolen wordt automatisch toegevoegd aan de tabel.

`coef_rename = c(...)`

:   Met deze functie kunnen we de namen van de onafhankelijke variabelen hernoemen. We doen dit voor het `intercept` en voor `cpi`. Voor zowel de originele naam als de nieuwe naam gebruik je dubbele (of enkele) aanhalingstekens.

`gof_map = c(...)`

:   Hier geven we aan welke "goodness of fit" (gof) statistieken we willen. We voegen hier de statistieken die we willen toe: het aantal observaties ("nobs"), de R² ("r.squared"), en de adjusted R² ("adj.r.squared"). De andere statistieken worden dan weggelaten.[^4]

`title = ...`

:   Titel voor de tabel.

`notes = (...)`

:   Onderschrift voor de tabel. Hier verduidelijk je aan de lezer wat er precies af te lezen valt: de lineaire regressiecoëfficiënten met standaardfouten tussen haakjes.

[^4]: Het alternatief is om `gof_omit()` te gebruiken en die statistieken die we niet willen te specificeren.

### Regressietabel met meerdere modellen

We kunnen `modelsummary()` ook gebruiken om een regressietabel met meerdere modellen te maken. Bijvoorbeeld, een model met enkel `cpi` en een model met alle predictors. We kunnen de modellen eerst in een lijst ('list') opslaan en dan `modelsummary()` op de lijst gebruiken. De rest van de syntax blijft grotendeels hetzelfde behalve de toevoeging van de andere onafhankelijke variabelen in het `coef_rename()` gedeelte.

```{r}
#model met 3 predictors
model2 <- lm(v2x_polyarchy ~ cpi + v2caviol + region, data = demdata)

#lijst maken
model_list <- list(model1, model2)

#lijst gebruiken in modelsummary()
modelsummary(model_list, 
             stars = TRUE, 
             coef_rename = c(
               "(Intercept)" = "Constante",
               "cpi" = "Corruptieperceptie-index", 
               "v2caviol" = "Politiek geweld",
               "regionAsia" = "Azië",
               "regionEurope" = "Europa", 
               "regionAmericas" = "Amerikas"), 
             gof_map = c("nobs", "r.squared", "adj.r.squared"), 
             title = "Electorale democratie voorspeld door corruptie, politiek geweld en regio", 
             notes = "Lineaire regressiecoëfficiënten met standaardfouten tussen haakjes. Referentiegroep regio = Afrika")

```

De functie zal standaard het eerste model 'Model 1' noemen en het tweede 'Model 2'. We kunnen dit desgewenst veranderen met behulp van onze lijst, waarin we dan niet alleen de namen van de objecten aangegeven maar ook de naam die we aan het model willen geven (door middel van: 'naam model in tabel' = object):

```{r}
#lijst met namen
model_list_named <- list(
  'Enkel Corruptie' = model1, 
  'Alle predictoren' = model2)

#tabel maken
modelsummary(model_list_named, 
             stars = TRUE, 
             coef_rename = c(
               "(Intercept)" = "Constante",
               "cpi" = "Corruptieperceptie-index", 
               "v2caviol" = "Politiek geweld",
               "regionAsia" = "Azië",
               "regionEurope" = "Europa", 
               "regionAmericas" = "Amerikas"), 
             gof_map = c("nobs", "r.squared", "adj.r.squared"), 
             title = "Electorale democratie voorspeld door corruptie, politiek geweld en regio", 
             notes = "Lineaire regressiecoëfficiënten met standaardfouten tussen haakjes. Referentiegroep regio = Afrika")

```

### Opslaan als Word document

We kunnen de regressietabellen gemaakt met `modelsummary()` ook opslaan in een Word document door de optie 'output' te gebruiken:

```{r}
modelsummary(model_list_named, 
             stars = TRUE, 
             coef_rename = c(
               "(Intercept)" = "Constante",
               "cpi" = "Corruptieperceptie-index", 
               "v2caviol" = "Politiek geweld",
               "regionAsia" = "Azië",
               "regionEurope" = "Europa", 
               "regionAmericas" = "Amerikas"), 
             gof_map = c("nobs", "r.squared", "adj.r.squared"), 
             title = "Electorale democratie voorspeld door corruptie, politiek geweld en regio", 
             notes = "Lineaire regressiecoëfficiënten met standaardfouten tussen haakjes. Referentiegroep regio = Afrika", 
             output = 'regressie_tabel.docx') 


```

`output = 'regressie_tabel.docx'`

:   Hier vragen we om een Word document (.docx) genaamd "regressie_tabel" op te slaan. Dit bestand vind je terug in je R project folder. Je kan ook een subfolder aanduiden, bv. "Output folder/regressie_tabel.docx". Let erop dat je het Word document niet geopend hebt als je de syntax opnieuw wil gebruiken met aanpassingen, anders kun je een foutmelding krijgen.

### Instructies

-   Het is gebruikelijk de ongestandaardiseerde coëfficiënt weer te geven met standaardfouten tussen haakjes onder de coëfficiënt. Dit is de standaardoutput voor de `modelsummary` functie. Standaard worden drie decimalen gebruikt. Dit is ook de conventie in de literatuur, maar het aantal decimalen kan aangepast worden met syntax. Standaardfouten kunnen echter ook tussen haakjes naast de coëfficiënt gezet worden.
-   Voorzie de tabel van een informatieve titel, duidelijke namen voor de variabelen en een notitie onderaan die verduidelijkt welke informatie precies wordt weergegeven.
-   Voor categorische variabelen kun je de referentiegroep op verschillende manieren verduidelijken: 1) je kunt deze informatie opnemen in de notitie zoals in het voorbeeld; 2) je kunt de referentiegroep aanduiden in de benaming van de variabele bv. "Azië (ref.: Afrika"; 3) je kunt de referentiegroep ook opnemen in een aparte rij in de tabel. Deze optie wordt beschreven op de `modelsummary` [webpagina](https://vincentarelbundock.github.io/modelsummary/articles/modelsummary.html#add_rows). De webpagina bevat ook verdere informatie om je tabel aan te passen naar voorkeur.
-   Standaard nummert `modelsummary` de modellen in de tabel (bv. (1), (2), etc.). Je kan echter ook een specifieke kolomnaam geven. Dit is bijvoorbeeld handig als modellen een andere afhankelijke variabele hebben.

## Plotten van coëfficiënten {#sec-presenting-linear-regression-coefficient-plots}

De resultaten van regressiemodellen kunnen ook in de vorm van een "coefficient plot" (plot van coëfficiënten) weergegeven worden. Deze plot bevat de coëfficiënten en hun betrouwbaarheidsintervallen (doorgaans op het 95% niveau). De constante wordt doorgaans niet opgenomen in de figuur.

Bij wijze van voorbeeld plotten we hier de resultaten van een model dat electorale democratie voorspelt op basis van corruptie, politiek geweld en regimestatus in 1984. We maken gebruik van de `tidy()` functie uit het `broom` package en de `ggplot()` functie uit het `tidyverse` package.

<!--- Note: switched models because the categorical variable was creating the need to discuss how to arrange it in the plot --->

```{r}
#Model
plot_model <- lm(v2x_polyarchy ~ cpi + v2caviol + TYPEDEMO1984, data = demdata)

#Oslaan van resultaten in tidy dataframe
#MOET betrouwbaarheidsintervallen bevatten
plot_model_tidied <- tidy(plot_model, conf.int = TRUE)

#resultaat bekijken
plot_model_tidied
```

We kunnen met deze data een figuur maken met `ggplot()` maar eerst doen we nog wat data management. We geven bijvoorbeeld andere namen aan de variabelen (opgeslaan in `term`) om duidelijker de resultaten te presenteren. [^5]

[^5]: We kunnen ook de volgorde waarin de variabelen verschijnen in het plot aanpassen. We doen dit door van `term`een factor te maken en dan de volgorde van de niveaus aan te passen met `relevel`.

```{r}
#duidelijkere namen:
plot_model_tidied <- plot_model_tidied |> 
  mutate(term = recode(term, 
                       "cpi" = "Corruptieperceptie-Index", 
                       "v2caviol" = "Politiek geweld",  
                       "TYPEDEMO1984Democracies" = "Democratie in 1984?"))

plot_model_tidied
```

Dan maken we het plot:

```{r}
plot_model_tidied |> 
  filter(term != "(Intercept)") |>  # <1> 
  ggplot(aes(x = estimate, y = term)) +  
  geom_pointrange(aes(xmin = conf.low, 
                      xmax = conf.high)) + 
  labs(title = "OLS coëfficiënten voor electorale democratie", 
       x = "OLS coëfficiënt", 
       y = "Onafhankelijke variabele") + 
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") + # <2>
  geom_text(aes(label = round(estimate, 2)), vjust = -0.5, hjust = -0.5) # <3> 
```

1.  filter intercept weg uit dataframe
2.  Voeg lijn toe bij x = 0
3.  Voeg de coëfficiënten toe aan het plot, afgerond op 2 decimalen

`plot_model_tidied |> filter(term != "(Intercept)") |>`

:   We gebruiken het data object dat we eerder aangemaakt hebben (`plot_model_tidied`) en filteren het intercept uit de data gezien die doorgaans niet geplot wordt.

`ggplot(aes(x=estimate, y=term)) +`

:   We gebruiken `ggplot()` en bepalen welke variabelen op de x--as (hier: 'estimate', de waarde voor de coëfficiënten) en de y-as (hier: de variabele `term` met de naam van onze variabelen) komen. De variabelen kunnen gewisseld worden van as, maar de getoonde manier levert meestal een betere visualisatie (anders zouden de namen van de variabelen kunnen overlappen).

`geom_pointrange(aes(xmin=conf.low, xmax=conf.high))`

:   Hier vragen we om de coefficiënten aan te duiden met een punt ("point"). Vervolgens vragen we om een lijn door het punt te tekenen om de reikwijdte ("range") van de betrouwbaarheidsintervallen voor te stellen. De `xmin` and `xmax` delen van de syntax bepalen de reikwijdte.[^6] Hier gebruiken we `conf.low` and `conf.high`, de variabelen waarin de ondergrens en bovengrens van de intervallen is opgeslaan.

`labs(...)`

:   We geven hier namen aan de assen en geven ook een titel.

`geom_vline(xintercept=0, linetype="dashed", color="red")`

:   Hier vragen we R om een verticale referentielijn te tekenen ("geom\_**v**line") waar x = 0. Deze lijn helpt met het bepalen van de significantie, aangezien overlap van het betrouwbaarheidsinterval met de lijn wijst op een niet-significante coëfficiënt.

`geom_text(aes(label = round(estimate, 2)), vjust = -0.5, hjust = -0.5)`

:   Hier vragen we om ook de waarde van de coëfficiënt weer te geven op de plot met `geom_text()`. De tekst die op het plot komt wordt bepaald met "label =". Hier vragen we om de 'estimate' (de coëfficiënt), maar afgerond ("round") tot 2 decimalen voor de duidelijkheid.

[^6]: Als we de coëfficiënten op de y-as plaatsen moeten we hier `ymin` en `ymax` aanduiden.

Met `vjust = -0.5` bepalen we waar de tekst komt ("*vertical* justification"). Dit kunnen we gebruiken om overlap tussen tekst en geplotte waarden te voorkomen. Negatieve waarden plaatsen de tekst hoger, positieve waarden plaatsen de tekst lager.

Met `hjust = -0.5` ("*horizontal* justification") kunnen we de tekst naar links (positieve waarden) of rechts (negatieve waarden) bewegen. In de praktijk kan het zijn dat je hier wat moet spelen met de waarden voor vjust en hjust om je plot goed te presenteren.

::: callout-important
#### Waarschuwing!

Standaard plot `ggplot` coëfficiënten van variabelen in alfabetische volgorde (is to order the coefficients by the alphabetical order of the variable that contains the variable names (named)zoals opgeslaan in de `term` variabele in het dataframe geproduceerd door `tidy()`). Dit is niet altijd ideaal, bijvoorbeeld wanneer categorieën van een factor variabele niet bij elkaar komen te staan of wanneer we vooral geïnteresseerd zijn in 1 bepaalde predictor en niet willen dat die in het midden komt te staan in plaats van prominent bovenaan.

Een voorbeeld:

```{r}
#Model met categorische variabele
cat_model <- lm(v2x_polyarchy ~ cpi + v2caviol + region, data = demdata)

#Tidy met simpel plot
tidy(cat_model, conf.int = TRUE) |> 
  filter(term != "(Intercept)") |> 
  mutate(term = recode(term, 
                       "cpi" = "Corruptieperceptie", 
                       "v2caviol" = "Politiek geweld",
                       "regionAsia" = "Azië",
                       "regionEurope" = "Europa", 
                       "regionAmericas" = "Amerikas")) |> 
    ggplot(aes(x = estimate, y=term)) + 
    geom_pointrange(aes(xmin = conf.low, xmax = conf.high)) +
    labs(title = "OLS coëfficiënten voor electorale democratie", 
       x = "OLS coëfficiënt", 
       y = "Onafhankelijke variabele")
```

De coëfficiënten van de categorische regio variable staan niet bij elkaar. We kunnen dit aanpassen door van `term`een factor te maken en dan de volgorde van de niveaus aan te passen met `relevel`.

```{r}
tidy(cat_model, conf.int = TRUE) |> 
  filter(term != "(Intercept)") |>  # <1>
  mutate(term = factor(term,
                       levels = c("regionEurope", "regionAsia", 
                                  "regionAmericas", "v2caviol",
                                  "cpi"),  # <2>
                       labels = c("Europa", "Azië", 
                                  "Amerikas", "Pol. geweld",
                                  "Corruptieperceptie"))) |> 
    ggplot(aes(x = estimate, y=term)) + 
    geom_pointrange(aes(xmin = conf.low, xmax = conf.high))+
    labs(title = "OLS coëfficiënten voor electorale democratie", 
       x = "OLS coëfficiënt", 
       y = "Onafhankelijke variabele")
```

1.  Omzetten naar een factor doe je nadat het intercept is weggefilterd. Dat kan in 1 stap zoals in het voorbeeld of in 2 aparte syntax-stappen.
2.  `ggplot()` zal het eerste niveau als onderste variabele plotten, het laatste niveau wordt de bovenste enzovoort.
:::

### Instructies

-   Meestal plaats je de coëfficiënt op de x-as en de naam van de variabele op de y-as. Het is mogelijk dit te veranderen met de `ggplot` syntax, maar dan kunnen de variabelenamen makkelijker overlappen. Lange variabelennamen leiden wel vaker tot problemen met de visualisatie (in deze [blog](https://www.andrewheiss.com/blog/2022/06/23/long-labels-ggplot/) vind je enkele tips).
-   Het toevoegen van de (afgeronde) coëfficiënt-waarde kan lezers helpen de resultaten beter te vatten.
-   Meestal plotten we de 95% betrouwbaarheidsintervallen, maar dit kan aangepast worden (we kunnen `tidy` om andere niveaus vragen).
-   In een rapport voeg je best een notitie onderaan de figuur toe, bv. "Notitie: OLS coëfficiënten met 95% betrouwbaarheidsinterval".
-   Het is handig en gebruikelijk een referentielijn toe te voegen die nul aanduidt want dan kan statistische significantie (hier: bij p \< 0.05) onmiddellijk afgelezen worden
-   Standaard plot `ggplot` de coëfficiënten in alfabetische volgorde. Dit kan ervoor zorgen dat variabelen die bij elkaar horen (bv. meerdere dummies van 1 onderliggende categorische variabele) niet bij elkaar staan in het plot. We kunnen de volgorde aanpassen als we de `term` variabele omzetten in een factor variabele en de volgorde van de levels zelf bepalen. Zie het 'waarschuwing'-vak hiervoven.
-   @gelman2006 maakte de welbekende uitspraak (althans onder statistici) dat "het verschil tussen 'significant' en 'niet significant' op zichzelf 'niet significant' is". Dit betekent dat je op basis van de betrouwbaarheidsintervallen van coëfficiënten en hun overlap niet kunt bepalen of coefficiënten significant van elkaar verschillen, je kan enkel bepalen of een coëfficiënt verschillend is van 0 (de nulhypothese).

## Voorspelde waarden plotten {#sec-presenting-linear-regression-predicted-values-plots}

Regressietabellen en coëfficiëntenplots presenteren de coëfficiënten voor de onafhankelijke variabelen in een model: wat is de verwachte gemiddelde waarde van de DV wanneer alle predictors = 0 (entercept of constante) en wat is de verwachte verandering in Y gegeven als X met één eenheid stijgt (coëfficiënten van onafhankelijke variabelen). We kunnen ook voorspelde waarden en grafieken van die voorspelde waarden gebruiken om discussies over coëfficiënten aan te vullen en meer te kunnen zeggen over het *substantiële* belang van de geschatte relatie.

Het proces is gelijkaardig dan dat van coëfficiëntenplots, maar nu maken we gebruik van de `predictions()` functie in plaats van `tidy()`. We werken immers met voorspellingen nu en niet de coëfficiënten. Zie @sec-predicted-residual-values voor meer informatie over de `predictions()` functie.

Hieronder geven we voorbeelden voor plots van voorspelde waarden op basis van continue en binaire/categorische onafhankelijke variabelen.

### Continue onafhankelijke variabele

Voor dit voorbeeld gebruiken we heet eerder geschatte `plot_model`, waarbij electorale democratiescores voorspeld worden aan de hand van de corruptieperceptie-index, politiek geweld, en regimestatus in het verleden. Stel nu dat corruptie (`cpi`) als continue predictor ons specifiek interesseert. We willen weten hoe demoratieniveau verandert op verschillende niveaus van corruptie. we gebruiken `predictions()` om de verwachte waarde voor v2x_polyarchy te berekenen wanneer corruptie waarden tussen 20 en 80 aanneemt (de andere onafhankelijke variabelen worden constant gehouden op hun gemiddelde of modus).

```{r}
#Voorspellingen berekenen
cpi_preds <- predictions(plot_model, 
                         newdata = datagrid(cpi = c(20, 30, 40, 50, 60, 70, 80)))

#en bekijken
cpi_preds
```

Deze data kunnen we invoeren in `ggplot()` om een plot te maken.

```{r}
ggplot(cpi_preds, aes(x = cpi, y = estimate)) + # <1> 
       geom_line () + # <2> 
       geom_ribbon(aes(ymin = conf.low, ymax = conf.high), # <3> 
                   alpha = 0.2) +  
       labs(title = "Voorspelde electorale democratiescore op basis van corruptieperceptie", # <4> 
            x = "Corruptieperceptie-index (Hoger = Minder corrupt)",   
            y = "Voorspelde waarde") +  
       scale_y_continuous(limits=c(0,1)) # <5>
```

1.  Duidt aan welke data en welk plot we willen gebruiken
2.  Duidt aan dat we een lijn willen die voorspelde waarden verbindt
3.  Duidt aan dat we een betrouwbaarheidsinterval willen en hoe donker dit interval geplot wordt
4.  Informatieve titel en labels
5.  De y-as zetten we van 0 tot 1 gezien dit het theoretisch bereik is van de afhankelijke variabele. Niet altijd nodig dit te doen.

`ggplot(`

:   : We gebruiken ggplot op het data object tussen haakjes.

`cpi_preds, aes(x = cpi, y = estimate)) +`

:   dataobject (`cpi_preds`) en de variabelen die we willen plotten op elke as.

`geom_line() +`

:   We vragen ggplot hier een lijn te trekken tussen de voorspelde waarden. Dit is gebruikelijk voor een continue onafhankelijke variabele.

`geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.2) +`

:   Hier vragen we om een band ('ribbon') rond de lijn te tekenen om de betrouwbaarheidsintervallen voor de voorspelde waarden weer te geven. Via `aes()` bepalen we welke variabelen de ligging van de band bepalen: de ondergrens (`ymin`) en bovengrens (`ymax`) van de betrouwbaarheidsintervallen. Met `alpha=0.2` bepalen we hoe donker de band is. Hogere waarden zijn donkerder en kunnen de zichtbaarheid van de lijn zelf hinderen.

`labs(...)`

:   We voegen titel en astitels toe.

`scale_y_continuous(limits = c(0,1))`

:   We bepalen met deze syntax de limieten van de y-as, hier tussen 0 en 1.

De limieten van de as zelf bepalen kan handig zijn om data duidelijker te visualiseren. We kunnen ervoor kiezen om de as het volledige theoretische bereik van de afhankelijke variabele te laten aannemen, zoals we hier doen met een y-as van 0 tot 1. Door het volledige bereik van de afhankelijke variabele te gebruiken lijken de effecten ook niet groter dan ze zijn. Echter kan deze benadering er soms wel voor zorgen dat een grafiek veel wit bevat en minder visueel aantrekkelijk is. Zie [this webpage](https://handsondataviz.org/how-to-lie-with-charts.html){target="_blank" rel="noreferrer noopener"} voor voorbeelden van wat er mis kan gaan. In de praktijk maken we een afweging. Wat we wel willen vermijden is dat de schaal groter is dan het theoretische bereik van de afhankelijke variabele.[^7]

[^7]: Socioloog Kieran Healy bespreekt meer in de diepte hoe data te inspecteren in zijn boek "Data Visualization", gratis beschikbaar [hier](https://socviz.co/){target="_blank" rel="noreferrer noopener"}. Zie in het bijzonder sectie 6 in Hoofdstuk 1, "Problems of honesty and good judgment".

### Binaire/categorische onafhankelijke variabele

Om voorspelde waarden voor een factor variabele te plotten is de procedure gelijkaardig. Hier plotten we de voorspelde waarden voor electoral democratie voor de verschillende niveaus van `TYPEDEMO1984`.

```{r}
#Voorspelde waarden berekenen
demo_preds <- predictions(plot_model, 
                          by = 'TYPEDEMO1984', 
                          newdata = 'mean')  # <1> 

#en bekijken: 
demo_preds
```

1.  Houdt de andere onafhankelijke variabelen op hun gemiddelde of modus

Dit data object voeren we door naar de `ggplot()` functie. We maken gebruik van `geom_pointrange()` zoals eerder voor het coëfficiëntenplot.

```{r}
ggplot(demo_preds, aes(x = TYPEDEMO1984, y = estimate)) + 
  geom_pointrange(aes(ymin = conf.low, ymax = conf.high)) + 
  labs(title = "Voorspelde democratiescore aan de hand van regime in het verleden", 
       y = "Voorspelde waarde", 
       x = "Regime in 1984") + 
  scale_y_continuous(limits = c(0,1)) +
  scale_x_discrete(labels = c("Autocracies" = "Autocratie", "Democracies" = "Democratie"))

```

`scale_x_discrete(labels = c(...)`

:   We veranderen de labels voor de categorische variabele naar het Nederlands.

We kunnen hier ook de effectieve voorspelde waarden toevoegen aan het plot met `geom_text`. We kunnen de positie van de tekst weer bepalen met vjust en/of hjust. Dit doen we vooral met categorische variabelen en niet met continue predictors.

```{r}
ggplot(demo_preds, aes(x=TYPEDEMO1984, y=estimate)) + 
  geom_pointrange(aes(ymin=conf.low, ymax=conf.high)) + 
  labs(title = "Voorspelde democratiescore aan de hand van regime in het verleden", 
       y = "Voorspelde waarde", 
       x = "Regime in 1984") + 
  geom_text(aes(label = round(estimate, 2)), hjust = -0.25)+
  scale_x_discrete(labels = c("Autocracies" = "Autocratie", "Democracies" = "Democratie"))
```

### Instructies

-   Welke variabelen en waarden plot je?
    -   Als de variabele binair/categorisch is, gebruik je alle categorieën die relevant zijn voor de discussie. (zie Week 3 R materialen voor een plot met categorieën).
    -   Als de variabele continue is gebruik je het minimum en maximum met redelijke tussenintervallen. Om het minimum en maximum te bepalen kijk je naar de data voor de observaties gebruikt in het model (dit is niet noodzakelijk de volledige dataset gezien observaties kunnen wegvallen door missing waarden). Met de `predictions()` kun je gemakkelijk een dataset aanmaken met alle observaties gebruikt in het model en vervolgens gebruik je `summary` om minimum en maximum te bepalen (zie @sec-predictions-for-a-continuous-predictor-variable).
-   Een lijn met 95% betrouwbaarheidsintervallen past bij een continue predictor, `geom_pointrange()` (of `geom_errorbar()`) bij een binaire/categorische variabele.
-   De y-schaal verdient bijzonder aandacht bij dit soort plots. In het voorbeeld wordt `scale_y_continuous()` gebruikt om ervoor te zorgen dat het plot het volledige bereik van de afhankelijke variabele (democratiescore) omvat. Soms maakt `ggplot()` zelf de schaal kleiner (om ongebruikte ruimte weg te laten), maar dan kan een effect groter lijken dan het is. Deze aanpak heeft ook wel nadelen, bijvoorbeeld juist veel ongebruikte ruimte in een plot en minder duidelijke visualisatie. Socioloog Kieran Healy geeft een verdere [bespreking](https://socviz.co/lookatdata.html#problems-of-honesty-and-good-judgment) over deze verschillende manieren om de schaal vorm te geven in zijn boek over datavisualisatie.
